# -*- coding: utf-8 -*-
"""Final Scientific Computing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sNCv4G8UpObxGWXVPkvldcUbOBNB7H-7
"""

import numpy as np

mX = [
        [
            [10, 2, -6],
            [-1, 4, 2],
            [2, 3, 6]
        ],
        [
            [-5, 2, -8],
            [4, -3, -9],
            [-8, -10, 9]
        ],
        [
            [10, -5, 3, 0],
            [3, -9, 2, -2],
            [-8, 0, 17, -4],
            [3, -3, -8, -15]
        ],
]

mY = [
    [17, -4, -12],
    [13, -7, -2],
    [9, 10, -10, -18]
]

def checkDiagonallyDominantWord(a):
  a = np.array(a)

  diag = np.diag(np.abs(a))
  sumWODiag = np.sum(np.abs(a), axis = 1)
  sumWODiag-=diag

  for i, el in enumerate(a):
    print(f'Diagonal {i+1} = {diag[i]}')
    print(f'Total of not diagonal value = ', end="")

    printedPlus = False
    for j, el2 in enumerate(el):
      if i!=j:
        if printedPlus:
          print(' + ', end='')
        print(f'|{el2}|', end='')
        printedPlus = True
    print(f' = {sumWODiag[i]}')
    if diag[i] > sumWODiag[i]:
      print(f'{diag[i]} > {sumWODiag[i]}')
    else:
      print(f'Because {diag[i]} < {sumWODiag[i]}, The equation is not Diagonally Dominant!')
      return False
  print('This equation is Diagonally Dominant!')
  return True

# ##################################################
#                      NO 1
# ##################################################
for i, el in enumerate(mX):
  print(f'Equation {i+1} Array X:')
  checkDiagonallyDominantWord(el)
  print()

def checkDiagonallyDominant(a):
  a = np.array(a)

  diag = np.diag(np.abs(a))
  sumWODiag = np.sum(np.abs(a), axis = 1)
  sumWODiag-=diag

  if np.all(diag > sumWODiag):
    print('This equation is Diagonally Dominant!')
    return True
  
  print('Not Diagonally Dominant!')
  return False

def getEquation(a, b):
  a = np.array(a)
  b = np.array(b)

  diag = np.diag(a)
  a = -a
  np.fill_diagonal(a, 0)

  for i, el in enumerate(a):
    print(f'X{i} = ({b[i]}', end="")
    for j, el2 in enumerate(el):
      if i!=j:
        print(f' + ', end="")
        print(f'({el2}X{j+1})', end="")
    print(f' ) / {diag[i]}')

def gaussSeidel(a, b, max):
  a = np.array(a)
  b = np.array(b)

  diag = np.diag(a)
  a = -a
  np.fill_diagonal(a, 0)

  oldVal = np.zeros(a.shape[0])
  for i in range(max):
    newVal = np.array(oldVal)
    for j, el in enumerate(a):
      newVal[j] = (b[j] + np.dot(newVal, el)) / diag[j]
    
    print(f'Iteration: {i+1}|', end='')
    for j, el in enumerate(newVal):
      print(f' X{j+1} = {newVal[j]: .8f}', end="")
      if j+1 == len(newVal):
        print()
      else:
        print(',', end='')

    dist = np.sqrt(np.dot(newVal-oldVal, newVal-oldVal))
    print(dist)
    if dist < 0.01456:
      print()
      print('Converged!')
      print('Result:')
      for j, el in enumerate(newVal):
        print(f'X{j+1} = {newVal[j]: .8f}')
      print()
      return
    oldVal = newVal
  print()
  print('Not Converged! Need more iteration!')
  return

# ##################################################
#                      NO 2
# ##################################################
for i, (x, y) in enumerate(zip(mX, mY)):
  print('===================================')
  print(f'Equation {i+1}')
  if checkDiagonallyDominant(x):
    getEquation(x, y)
    gaussSeidel(x, y, 5)
  print()

# ##################################################
#                      NO 3
# ##################################################

from matplotlib import pyplot as plt
x = [1, 5, 7, 2, 3, 9, 10, 4, 6, 8]
y = [34, 51, 80, 25, 90, 76, 100, 11, 45, 62]

A = np.vstack([x, np.ones(len(x))]).T
Y = np.vstack(y)

first = np.linalg.inv(np.dot(A.T, A)).T
final = np.dot(np.dot(first, A.T), Y)

m = final[0]
b = final[1]

plt.title('Least Square Regression')
plt.xlabel('X')
plt.ylabel('Y')
plt.plot(x, y, 'ro', label="asu")
plt.plot(x, m*x+b, 'g', label="babi")
plt.legend()
plt.figure(figsize=(12, 8))
plt.show()

# ##################################################
#                      NO 4
# ##################################################
import numpy as np
from sympy import *

x = symbols('x')
f1 = lambda x: 7*x**4 - 3*x**2 + x
f2 = lambda x: 8*x**6 + 5*x**4 - 2

df1 = diff(f1(x), x)
df2 = diff(f2(x), x)
df1 = lambdify(x, df1, 'numpy')
df2 = lambdify(x, df2, 'numpy')

def newton_raphson(f, df, x0, tol, max):
  if max == 0:
    print('With current iteration, the root is not found')
    return 
  if np.abs(f(x0)) < tol:
    print(f'The Root: {x0}')
    return x0
  else:
    xNew = x0 - (f(x0) / df(x0))
    print(f'Iteration {6-max}, root: {xNew}')
    return newton_raphson(f, df, xNew, tol, max-1)

print('Equation 1')
print(str(f1(x)).replace('**', '^').replace('*', ''))
print('f(x) = 7x^4 - 3x^2 + x')
print('f\'(x) = 28x^3 - 6x + 1')
print()
newton_raphson(f1,df1,1,0.006541, 5)

print('Equation 2')
print('f(x) = 8x^6 + 5x^4 - 2')
print('f\'(x) = 48x^5 + 20x^3')
print()
newton_raphson(f2,df2,1,0.006541, 5)

def f(x):
  return 3*x**4 - 7*x**2 + 5

# ##################################################
#                      NO 5
# ##################################################

a = 3
b = -4
n = 30

boxWidth = (a-b)/(n-1)
x = np.linspace(b, a, n)

xLeft = x[ :-1]
yLeft = f(xLeft)
leftRiemann = boxWidth * np.sum(np.abs(yLeft))

xRight = x[1: ]
yRight = f(xRight)
rightRiemann = boxWidth * np.sum(np.abs(yRight))

xMid = (xLeft + xRight) / 2
yMid = f(xMid)
midRiemann = boxWidth * np.sum(np.abs(yMid))

trapeziod = boxWidth * np.sum(np.abs(yLeft) + np.abs(yRight)) / 2

print(leftRiemann)
print(rightRiemann)
print(midRiemann)
print(trapeziod)